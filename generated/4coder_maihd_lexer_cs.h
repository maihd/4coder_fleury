#if !defined(FCODER_LEX_GEN_HAND_WRITTEN_TYPES)
#define FCODER_LEX_GEN_HAND_WRITTEN_TYPES

struct Lexeme_Table_Value{
    Token_Base_Kind base_kind;
    u16 sub_kind;
};

struct Lexeme_Table_Lookup{
    b32 found_match;
    Token_Base_Kind base_kind;
    u16 sub_kind;
};

#endif
typedef u16 Token_CS_Kind;
enum{
TokenCSKind_EOF = 0,
TokenCSKind_Whitespace = 1,
TokenCSKind_LexError = 2,
TokenCSKind_BlockComment = 3,
TokenCSKind_LineComment = 4,
TokenCSKind_Backslash = 5,
TokenCSKind_LiteralInteger = 6,
TokenCSKind_LiteralIntegerU = 7,
TokenCSKind_LiteralIntegerL = 8,
TokenCSKind_LiteralIntegerUL = 9,
TokenCSKind_LiteralIntegerLL = 10,
TokenCSKind_LiteralIntegerULL = 11,
TokenCSKind_LiteralIntegerHex = 12,
TokenCSKind_LiteralIntegerHexU = 13,
TokenCSKind_LiteralIntegerHexL = 14,
TokenCSKind_LiteralIntegerHexUL = 15,
TokenCSKind_LiteralIntegerHexLL = 16,
TokenCSKind_LiteralIntegerHexULL = 17,
TokenCSKind_LiteralIntegerOct = 18,
TokenCSKind_LiteralIntegerOctU = 19,
TokenCSKind_LiteralIntegerOctL = 20,
TokenCSKind_LiteralIntegerOctUL = 21,
TokenCSKind_LiteralIntegerOctLL = 22,
TokenCSKind_LiteralIntegerOctULL = 23,
TokenCSKind_LiteralFloat32 = 24,
TokenCSKind_LiteralFloat64 = 25,
TokenCSKind_LiteralString = 26,
TokenCSKind_LiteralCharacter = 27,
TokenCSKind_PPErrorMessage = 28,
TokenCSKind_KeywordGeneric = 29,
TokenCSKind_BraceOp = 30,
TokenCSKind_BraceCl = 31,
TokenCSKind_ParenOp = 32,
TokenCSKind_BrackOp = 33,
TokenCSKind_ParenCl = 34,
TokenCSKind_BrackCl = 35,
TokenCSKind_Semicolon = 36,
TokenCSKind_Colon = 37,
TokenCSKind_Eq = 38,
TokenCSKind_Dot = 39,
TokenCSKind_Plus = 40,
TokenCSKind_Minus = 41,
TokenCSKind_Not = 42,
TokenCSKind_Tilde = 43,
TokenCSKind_Star = 44,
TokenCSKind_And = 45,
TokenCSKind_Div = 46,
TokenCSKind_Mod = 47,
TokenCSKind_LeftLeft = 48,
TokenCSKind_RightRight = 49,
TokenCSKind_Less = 50,
TokenCSKind_LessEq = 51,
TokenCSKind_Grtr = 52,
TokenCSKind_GrtrEq = 53,
TokenCSKind_EqEq = 54,
TokenCSKind_NotEq = 55,
TokenCSKind_Xor = 56,
TokenCSKind_Or = 57,
TokenCSKind_AndAnd = 58,
TokenCSKind_OrOr = 59,
TokenCSKind_Ternary = 60,
TokenCSKind_PlusEq = 61,
TokenCSKind_MinusEq = 62,
TokenCSKind_StarEq = 63,
TokenCSKind_DivEq = 64,
TokenCSKind_ModEq = 65,
TokenCSKind_LeftLeftEq = 66,
TokenCSKind_RightRightEq = 67,
TokenCSKind_Comma = 68,
TokenCSKind_Operator = 69,
TokenCSKind_Using = 70,
TokenCSKind_Namespace = 71,
TokenCSKind_Void = 72,
TokenCSKind_String = 73,
TokenCSKind_Bool = 74,
TokenCSKind_Float = 75,
TokenCSKind_Double = 76,
TokenCSKind_Decimal = 77,
TokenCSKind_Int = 78,
TokenCSKind_Long = 79,
TokenCSKind_Byte = 80,
TokenCSKind_Short = 81,
TokenCSKind_Uint = 82,
TokenCSKind_Ulong = 83,
TokenCSKind_Ushort = 84,
TokenCSKind_Char = 85,
TokenCSKind_Sbyte = 86,
TokenCSKind_Struct = 87,
TokenCSKind_Class = 88,
TokenCSKind_Enum = 89,
TokenCSKind_SizeOf = 90,
TokenCSKind_TypeOf = 91,
TokenCSKind_NameOf = 92,
TokenCSKind_New = 93,
TokenCSKind_Delete = 94,
TokenCSKind_Break = 95,
TokenCSKind_Case = 96,
TokenCSKind_Continue = 97,
TokenCSKind_Default = 98,
TokenCSKind_Do = 99,
TokenCSKind_Else = 100,
TokenCSKind_For = 101,
TokenCSKind_Foreach = 102,
TokenCSKind_Goto = 103,
TokenCSKind_If = 104,
TokenCSKind_Return = 105,
TokenCSKind_Switch = 106,
TokenCSKind_While = 107,
TokenCSKind_In = 108,
TokenCSKind_Out = 109,
TokenCSKind_Ref = 110,
TokenCSKind_Public = 111,
TokenCSKind_Private = 112,
TokenCSKind_Protected = 113,
TokenCSKind_Internal = 114,
TokenCSKind_Var = 115,
TokenCSKind_Const = 116,
TokenCSKind_Static = 117,
TokenCSKind_Readonly = 118,
TokenCSKind_LiteralNull = 119,
TokenCSKind_LiteralTrue = 120,
TokenCSKind_LiteralFalse = 121,
TokenCSKind_Identifier = 122,
TokenCSKind_PPDefine = 123,
TokenCSKind_PPUndef = 124,
TokenCSKind_PPElse = 125,
TokenCSKind_PPElIf = 126,
TokenCSKind_PPEndIf = 127,
TokenCSKind_PPError = 128,
TokenCSKind_PPLine = 129,
TokenCSKind_PPIf = 130,
TokenCSKind_PPUnknown = 131,
TokenCSKind_PPDefined = 132,
TokenCSKind_COUNT = 133,
};
char *token_cs_kind_names[] = {
"EOF",
"Whitespace",
"LexError",
"BlockComment",
"LineComment",
"Backslash",
"LiteralInteger",
"LiteralIntegerU",
"LiteralIntegerL",
"LiteralIntegerUL",
"LiteralIntegerLL",
"LiteralIntegerULL",
"LiteralIntegerHex",
"LiteralIntegerHexU",
"LiteralIntegerHexL",
"LiteralIntegerHexUL",
"LiteralIntegerHexLL",
"LiteralIntegerHexULL",
"LiteralIntegerOct",
"LiteralIntegerOctU",
"LiteralIntegerOctL",
"LiteralIntegerOctUL",
"LiteralIntegerOctLL",
"LiteralIntegerOctULL",
"LiteralFloat32",
"LiteralFloat64",
"LiteralString",
"LiteralCharacter",
"PPErrorMessage",
"KeywordGeneric",
"BraceOp",
"BraceCl",
"ParenOp",
"BrackOp",
"ParenCl",
"BrackCl",
"Semicolon",
"Colon",
"Eq",
"Dot",
"Plus",
"Minus",
"Not",
"Tilde",
"Star",
"And",
"Div",
"Mod",
"LeftLeft",
"RightRight",
"Less",
"LessEq",
"Grtr",
"GrtrEq",
"EqEq",
"NotEq",
"Xor",
"Or",
"AndAnd",
"OrOr",
"Ternary",
"PlusEq",
"MinusEq",
"StarEq",
"DivEq",
"ModEq",
"LeftLeftEq",
"RightRightEq",
"Comma",
"Operator",
"Using",
"Namespace",
"Void",
"String",
"Bool",
"Float",
"Double",
"Decimal",
"Int",
"Long",
"Byte",
"Short",
"Uint",
"Ulong",
"Ushort",
"Char",
"Sbyte",
"Struct",
"Class",
"Enum",
"SizeOf",
"TypeOf",
"NameOf",
"New",
"Delete",
"Break",
"Case",
"Continue",
"Default",
"Do",
"Else",
"For",
"Foreach",
"Goto",
"If",
"Return",
"Switch",
"While",
"In",
"Out",
"Ref",
"Public",
"Private",
"Protected",
"Internal",
"Var",
"Const",
"Static",
"Readonly",
"LiteralNull",
"LiteralTrue",
"LiteralFalse",
"Identifier",
"PPDefine",
"PPUndef",
"PPElse",
"PPElIf",
"PPEndIf",
"PPError",
"PPLine",
"PPIf",
"PPUnknown",
"PPDefined",
};
